/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _isValidISODate = __webpack_require__(/*! ./isValidISODate */ \"./src/isValidISODate.js\");\n\nvar _isValidISODate2 = _interopRequireDefault(_isValidISODate);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar DEFAULTS = { sortDir: \"ASC\", sortBy: null, throwError: false };\n\nvar getOptions = function getOptions(options) {\n  return _extends({}, DEFAULTS, options);\n};\n\nvar getType = function getType(val) {\n  var type = typeof val === \"undefined\" ? \"undefined\" : _typeof(val);\n  if (type === \"string\") {\n    return (0, _isValidISODate2.default)(val) ? \"date\" : \"string\";\n  }\n  return type;\n};\n\nvar asc = function asc(a, b, indexA, indexB) {\n  if (a > b) return 1;\n  if (b > a) return -1;\n  return indexA - indexB; //if value is the same, preserves asc order of the original set\n};\n\nvar desc = function desc(a, b, indexA, indexB) {\n  if (a > b) return -1;\n  if (b > a) return 1;\n  return indexB - indexA; //if value is the same, preserves desc order of the original set\n};\n\nvar getValueByPath = function getValueByPath(propertyName, object) {\n  var parts = propertyName.split(\".\");\n  return parts.reduce(function (acc, curr) {\n    return acc[curr];\n  }, object);\n};\n\nvar fallbacksortBy = function fallbacksortBy(item) {\n  var sortBy = Array.isArray(item) ? \"0\" : Object.keys(item)[0];\n  if (_typeof(item[sortBy]) === \"object\") {\n    sortBy += \".\" + fallbacksortBy(item[sortBy]);\n  }\n  return sortBy;\n};\n\nvar checkForDifferentTypes = function checkForDifferentTypes(itemA, itemB) {\n  if (getType(itemA) !== getType(itemB) || Array.isArray(itemA) !== Array.isArray(itemB)) {\n    throw new Error(\"Different types cannot be compared\");\n  }\n};\n\nvar compare = function compare(a, b, sortDir, sortBy, throwError) {\n  //clones parameters for manipulation\n  var itemA = a.data;\n  var itemB = b.data;\n  var sortParameter = sortBy;\n\n  //if we have different types in the list, error is thrown\n  checkForDifferentTypes(itemA, itemB);\n\n  //array of objects or array of arrays\n  if (getType(itemA) === \"object\") {\n    //fallback for missing sortParameter\n    if (!sortParameter || !sortParameter.length) {\n      sortParameter = fallbacksortBy(itemA);\n    }\n\n    //given the path in sortBy (path.to.key) gets the correct value to compare\n    itemA = getValueByPath(sortParameter, itemA);\n    itemB = getValueByPath(sortParameter, itemB);\n\n    checkForDifferentTypes(itemA, itemB);\n\n    //throws error for undefined values\n    if (itemA === undefined) {\n      throw new Error(\"Specified sortBy (\" + sortBy + \") has not been found on item \" + JSON.stringify(a.data) + \".\");\n    }\n    if (itemB === undefined) {\n      throw new Error(\"Specified sortBy (\" + sortBy + \") has not been found on item \" + JSON.stringify(b.data) + \".\");\n    }\n  }\n\n  //sort function\n  return sortDir === \"DESC\" ? desc(itemA, itemB, a.id, b.id) : asc(itemA, itemB, a.id, b.id);\n};\n\nvar execSort = function execSort(list, sortDir, sortBy, throwError) {\n  try {\n    return list.sort(function (a, b) {\n      return compare(a, b, sortDir, sortBy, throwError);\n    });\n  } catch (err) {\n    if (throwError) throw err;\n    return null;\n  }\n};\n\n/** A function to sort an array in a type-aware mode\n * @param {Array.<any>} items  - Array to sort. The items have to be of the same type\n * @param [{Object}] options - Include options parameters to be used\n * @param {string='ASC'} options.sortDir  - Direction to sort to. It can be 'ASC' or 'DESC'\n * @param {string||Array.strings=null} options.sortBy - In case of objects array, the field(s) to use to sort, if null fallsback to first key in object\n * @param {boolean=true} options.throwError - If set to true in case of error returns the error, otherwise returns the array in the original order\n * @return {Array.<any>} - The sorted array\n */\nvar sort = function sort(items, options) {\n  var _getOptions = getOptions(options),\n      sortDir = _getOptions.sortDir,\n      sortBy = _getOptions.sortBy,\n      throwError = _getOptions.throwError;\n  //check if items is array\n\n\n  if (!Array.isArray(items)) {\n    if (throwError) {\n      throw new Error(\"Items must be an array\");\n    }\n    return items;\n  }\n\n  if (sortBy && Array.isArray(sortBy)) {\n    if (sortBy.some(function (i) {\n      return typeof i !== \"string\";\n    })) {\n      if (throwError) {\n        throw new Error(\"[sortBy] must be a string or an array of strings\");\n      }\n      return items;\n    }\n  } else if (sortBy && typeof sortBy !== \"string\") {\n    if (throwError) {\n      throw new Error(\"[sortBy] must be a string or an array of strings\");\n    }\n    return items;\n  }\n\n  //list is items data with a progressive id to preserve order if value is the same\n  var list = items.map(function (data, id) {\n    return { id: id, data: data };\n  });\n\n  var sorted = void 0;\n  if (!sortBy || !Array.isArray(sortBy)) {\n    sorted = execSort(list, sortDir, sortBy, throwError);\n  } else {\n    //sorts and gets data of lists in reverse order (priority) of given sortBy array\n    sorted = sortBy.reverse().reduce(function (acc, curr) {\n      return execSort(acc, sortDir, curr, throwError);\n    }, list);\n  }\n\n  return sorted ? sorted.map(function (val) {\n    return val.data;\n  }) : items;\n\n  return list;\n};\n\nexports.default = sort;\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/isValidISODate.js":
/*!*******************************!*\
  !*** ./src/isValidISODate.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// Regex to match ISO8601 format\n// DR: it handles all the format rules, but doesn't check for valid days in a specific month. Possible future improvements.\nvar regex = /^([-+]?\\d{4})(-(?:(?:W(?:0[^0]|5[0-3]|[1-4][0-9])(-[1-7])?)|(?:(?:0[^0]|1[0-2])(-(?:0[^0]|[1-2]\\d|3[0-1]))?)))?(T(?:[0-1]\\d|2[0-3])(?::[0-5]\\d)?(?::[0-5]\\d)?(?:Z|[+-](?:[0-1]\\d|2[0-3])(?::[0-5]\\d)?)?)?$/;\n\nvar daysInMonth = function daysInMonth(month, year) {\n  switch (month) {\n    case 1:\n      return year % 4 == 0 && year % 100 || year % 400 == 0 ? 29 : 28;\n    case 8:\n    case 3:\n    case 5:\n    case 10:\n      return 30;\n    default:\n      return 31;\n  }\n};\n\nvar isValidDate = function isValidDate(day, month, year) {\n  month = parseInt(month, 10) - 1;\n  return month >= 0 && month < 12 && day > 0 && day <= daysInMonth(month, year);\n};\n\n/**\n * Check if a date is a valid ISO8601 date\n * @param {string} date The date\n */\nvar isValidISODate = function isValidISODate(date) {\n  if (!RegExp(regex).test(date)) {\n    return false;\n  }\n\n  var parsedDate = new Date(date);\n  return isValidDate(parsedDate.getDate(), parsedDate.getMonth() + 1, parsedDate.getFullYear());\n};\n\nexports.default = isValidISODate;\n\n//# sourceURL=webpack:///./src/isValidISODate.js?");

/***/ })

/******/ });